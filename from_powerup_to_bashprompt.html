<!DOCTYPE html>
<html><head><title>L.A.I.N. Pet Project</title></head><body>
  <h1>From Power Up To Bash Prompt</h1>
  <p>Greg O'Keefe, gcokeefe@postoffice.utas.edu.au</p>
  <p>v0.9, November 2000</p>
  <p>This is a brief description of what happens in a Linux system, from the time that you turn on the power, to the time that you log in and get a bash prompt. Understanding this will be helpful when you need to solve problems or configure your system.</p><hr>
  <h2>1. Introduction</h2>
  <p>I find it frustrating that many things happen inside my Linux machine that I do not understand. If, like me, you want to really understand your system rather than just knowing how to use it, this document should be a good place to start. This kind of background knowledge is also needed if you want to be a top notch Linux problem solver.</p>
  <p>I assume that you have a working Linux box, and understand some basic things about Unix and PC hardware. If not, an excellent place to start learning is Eric S. Raymond's The Unix and Internet Fundamentals HOWTO It is short, very readable and covers all the basics.</p>
  <p>The main thread in this document is how Linux starts itself up. But it also tries to be a more comprehensive learning resource. I have included exercises in each section. If you actually do some of these, you will learn much more than you could by just reading.<p>
  <p>I hope some readers will undertake the best Linux learning exercise that I know of, <strong>which is building a system from source code.</strong> Giambattista Vico, an Italian philosopher (1668-1744) said ``verum ipsum factum'', which means ``understanding arises through making''. Thanks to Alex (see Acknowledgements) for this quote.</p>
  <q>Now, this is a good idea, L.A.I.N might become my toy/pet system in the future built from source Linux from Scratch style just to learn about the system. Turns out this was the best document to begin Lain Lore after all!</q>
  <p>If you want to <i>``roll your own''</i>, you should also see Gerard Beekmans' Linux From Scratch HOWTO (LFS). LFS has detailed instructions on building a complete useable system from source code. On the LFS website, you will also find a mailing list for people building systems this way. The instructions that used to be part of this document are now in a separate document ``Building a Minimal Linux System from Source Code'', and can be found at From PowerUp to Bash Prompt home page. They explain how to ``toy'' system, purely as a learning exercise.</p>
  <p>Packages are presented in the order in which they appear in the system startup process. This means that if you install the packages in this order you can reboot after each installation, and see the system get a little closer to giving you a bash prompt each time. There is a reassuring sense of progress in this.</p>
  <p>I recommend that you first read the main text of each section, skipping the exercises and references. Then decide how deep an understanding you want to develop, and how much effort you are prepared to put in. Then start at the beginning again, doing the exercises and additional reading as you go.</p><hr>
  <h2>2. Hardware</h2>
  <p>When you first turn on your computer it tests itself to make sure everything is in working order. This is called the <strong>``Power on self test''</strong>. Then a program called the <strong>bootstrap loader</strong>, located in the <strong>ROM BIOS</strong>, looks for a boot sector. A <strong>boot sector</strong> is the first sector of a disk and has a small program that can load an operating system. Boot sectors are marked with a magic number <i>0xAA55 = 43603</i> at byte <i>0x1FE = 510</i>. That's the last two bytes of the sector. This is how the hardware can tell whether the sector is a boot sector or not.</p>

  <p>Addendum: Magic number<p>
  <p>One way to incorporate file type metadata, often associated with Unix and its derivatives, is to store a "magic number" inside the file itself. Originally, this term was used for a specific set of 2-byte identifiers at the beginnings of files, but since any binary sequence can be regarded as a number, any feature of a file format which uniquely distinguishes it can be used for identification. GIF images, for instance, always begin with the ASCII representation of either GIF87a or GIF89a, depending upon the standard to which they adhere. Many file types, especially plain-text files, are harder to spot by this method. HTML files, for example, might begin with the string &lt;html&gt; (which is not case sensitive), or an appropriate document type definition that starts with &lt;!DOCTYPE HTML&gt;, or, for XHTML, the XML identifier, which begins with &lt;?xml. The files can also begin with HTML comments, random text, or several empty lines, but still be usable HTML.</p>
  <p>The magic number approach offers better guarantees that the format will be identified correctly, and can often determine more precise information about the file. Since reasonably reliable "magic number" tests can be fairly complex, and each file must effectively be tested against every possibility in the magic database, this approach is relatively inefficient, especially for displaying large lists of files (in contrast, file name and metadata-based methods need to check only one piece of data, and match it against a sorted index). Also, data must be read from the file itself, increasing latency as opposed to metadata stored in the directory. Where file types don't lend themselves to recognition in this way, the system must fall back to metadata. It is, however, the best way for a program to check if the file it has been told to process is of the correct format: while the file's name or metadata may be altered independently of its content, failing a well-designed magic number test is a pretty sure sign that the file is either corrupt or of the wrong type. On the other hand, a valid magic number does not guarantee that the file is not corrupt or is of a correct type.</p>
  <p>So-called shebang lines in script files are a special case of magic numbers. Here, the magic number is human-readable text that identifies a specific command interpreter and options to be passed to the command interpreter.</p>
  <p>Another operating system using magic numbers is AmigaOS, where magic numbers were called "Magic Cookies" and were adopted as a standard system to recognize executables in Hunk executable file format and also to let single programs, tools and utilities deal automatically with their saved data files, or any other kind of file types when saving and loading data. This system was then enhanced with the Amiga standard Datatype recognition system. Another method was the FourCC method, originating in OSType on Macintosh, later adapted by Interchange File Format (IFF) and derivatives.</p>
  <p>External metadata</p>
  <p>A final way of storing the format of a file is to explicitly store information about the format in the file system, rather than within the file itself.</p>
  <p>This approach keeps the metadata separate from both the main data and the name, but is also less portable than either filename extensions or "magic numbers", since the format has to be converted from filesystem to filesystem. While this is also true to an extent with filename extensions— for instance, for compatibility with MS-DOS's three character limit— most forms of storage have a roughly equivalent definition of a file's data and name, but may have varying or no representation of further metadata.</p>
  <p>Note that zip files or archive files solve the problem of handling metadata. A utility program collects multiple files together along with metadata about each file and the folders/directories they came from all within one new file (e.g. a zip file with extension .zip). The new file is also compressed and possibly encrypted, but now is transmissible as a single file across operating systems by FTP transmissions or sent by email as an attachment. At the destination, the single file received has to be unzipped by a compatible utility to be useful. The problems of handling metadata are solved this way using zip files or archive files. End of the addendum!</P>
  <p>The bootstrap loader has a list of places to look for a boot sector. My old machine looks in the primary floppy drive, then the primary hard drive. More modern machines can also look for a boot sector on a CD-ROM. If it finds a boot sector, it loads it into memory and passes control to the program that loads the operating system. On a typical Linux system, this program will be <strong>LILO's first stage boot loader</strong>. There are many different ways of setting your system up to boot though. See the LILO User's Guide for details. See section LILO for a URL.</p>
  <p>Obviously there is a lot more to say about what PC hardware does. But this is not the place to say it. See one of the many good books about PC hardware.</p>
  <h2>2.1 Configuration</h2>
  <p>The machine stores some information about itself in its CMOS. This includes what disks and RAM are in the system. The machine's BIOS contains a program to let you modify these settings. Check the messages on your screen as the machine is turned on to see how to access it. On my machine, you press the delete key before it begins loading its operating system.</p>
  <p>Addendum begin:In computing, BIOS (/ˈbaɪɒs, -oʊs/, BY-oss, -&lt;ohss&gt;; Basic Input/Output System, also known as the System BIOS, ROM BIOS, BIOS ROM or PC BIOS) is firmware used to provide runtime services for operating systems and programs and to perform hardware initialization during the booting process (power-on startup).[1] The BIOS firmware comes pre-installed on an IBM PC or IBM PC compatible's system board and exists in some UEFI-based systems too as a compatibly support module to maintain compatibility operating systems that do not support UEFI native operation.[2][3] The name originates from the Basic Input/Output System used in the CP/M operating system in 1975.[4][5] The BIOS originally proprietary to the IBM PC has been reverse engineered by some companies (such as Phoenix Technologies) looking to create compatible systems. The interface of that original system serves as a de facto standard.</p>
  <p>The BIOS in modern PCs initializes and tests the system hardware components (Power-on self-test), and loads a boot loader from a mass storage device which then initializes a kernel. In the era of DOS, the BIOS provided BIOS interrupt calls for the keyboard, display, storage, and other input/output (I/O) devices that standardized an interface to application programs and the operating system. More recent operating systems do not use the BIOS interrupt calls after startup.[6]</p>
  <p>Most BIOS implementations are specifically designed to work with a particular computer or motherboard model, by interfacing with various devices especially system chipset. Originally, BIOS firmware was stored in a ROM chip on the PC motherboard. In later computer systems, the BIOS contents are stored on flash memory so it can be rewritten without removing the chip from the motherboard. This allows easy, end-user updates to the BIOS firmware so new features can be added or bugs can be fixed, but it also creates a possibility for the computer to become infected with BIOS rootkits. Furthermore, a BIOS upgrade that fails could brick the motherboard. The last version of Microsoft Windows running on PCs which uses BIOS firmware is Windows 10. End of addendum.</p>
  <h2>2.2 Exercises</h2>
  <p>A good way to learn about PC hardware is to build a machine out of second hand parts. Get at least a 386 so you can easily run Linux on it. It won't cost much. Ask around, someone might give you some of the parts you need.</p>
  <p>Check out, download compile and make a boot disk for Unios. <i>(They used to have a home page at http://www.unios.org, but it disappeared)</i> This is just a bootable ``Hello World!'' program, consisting of just over 100 lines of assembler code. It would be good to see it converted to a format that the GNU assembler can understand.</p>
  <p>Open the boot disk image for unios with a hex editor. This image is 512 bytes long, exactly one sector. Find the magic number 0xAA55. Do the same for the boot sector from a bootable floppy disk or your own computer. You can use the dd command to copy it to a file: <code>dd if=/dev/fd0 of=boot.sector.</code> Be very careful to get <i>if</i> (input file) and <i>of</i> (output file) the right way round!</p>
  <p>Check out the source code for LILO's boot loader.</p>
  <h2>2.3 More Information</h2>
  <p>The Unix and Internet Fundamentals HOWTO by Eric S. Raymond, especially section 3, What happens when you switch on a computer?</p>
  <p>The first chapter of The LILO User's Guide gives an excellent explanation of PC disk partitions and booting. See section LILO for a URL.</p>
  <p>The NEW Peter Norton Programmer's Guide to the IBM PC & PS/2, by Peter Norton and Richard Wilton, Microsoft Press 1988 There is a newer Norton book, which looks good, but I can't afford it right now!</p>
  <p>One of the many books available on upgrading PC's</p><hr>
  <h2>3. Lilo</h2>
  <p>When the computer loads a boot sector on a normal Linux system, what it loads is actually a part of lilo, called the <strong>``first stage boot loader''</strong>. This is a tiny program who's only job in life is to load and run the <strong>``second stage boot loader''</strong>.</p>
  <p>The second stage loader gives you a prompt (if it was installed that way) and loads the operating system you choose.</p>
  <p>When your system is up and running, and you run lilo, what you are actually running is the <strong>``map installer''</strong>. This reads the configuration file /etc/lilo.conf and writes the boot loaders, and information about the operating systems it can load, to the hard disk.</p>
  <p>There are lots of different ways to set your system up to boot. What I have just explained is the most obvious and <i>``normal''</i> way, at least for a system who's main operating system is Linux. The Lilo Users' Guide explains several examples of ``boot concepts''. It is worth reading these, and trying some of them out.</p>
  <h2>3.1 Configuration</h2>
  <p>The configuration file for lilo is /etc/lilo.conf. There is a manual page for it: type man lilo.conf into a shell to see it.<strong>Note: The manual is not present on my system [Xubuntu]</strong> The main thing in lilo.conf is one entry for each thing that lilo is set up to boot. For a Linux entry, this includes where the kernel is, and what disk partition to mount as the root filesystem. For other operating systems, the main piece of information is which partition to boot from.</p>
  <h2>3.2 Exercises</h2>
  <p><strong>DANGER:</strong> take care with these exercises. It is easy enough to get something wrong and screw up your master boot record and make your system unuseable. Make sure you have a working rescue disk, and know how to use it to fix things up again. See below for a link to tomsrtbt, the rescue disk I use and recommend. The best precaution is to use a machine that doesn't matter.</p><p>Addendum:LILO (Linux Loader) is a boot loader for Linux and was the default boot loader for most Linux distributions in the years after the popularity of loadlin.[when?] Today[when?], many distributions use GRUB as the default boot loader, but LILO and its variant ELILO are still in wide use. Further development of LILO was discontinued in December 2015 along with a request by Joachim Wiedorn for potential developers.</p>
  <p>Set up lilo on a floppy disk. It doesn't matter if there is nothing other than a kernel on the floppy - you will get a ``kernel panic'' when the kernel is ready to load init, but at least you will know that lilo is working.</p>
  <p>If you like you can press on and see how much of a system you can get going on the floppy. This is probably the second best Linux learning activity around. See the Bootdisk HOWTO (url below), and tomsrtbt (url below) for clues.</p>
  <p>Get lilo to boot unios <i>(see section hardware exercises for a URL)</i>. As an extra challenge, see if you can do this on a floppy disk.</p>
  <p>Make a boot-loop. Get lilo in the master boot record to boot lilo in one of the primary partition boot sectors, and have that boot lilo in the master boot record... Or perhaps use the master boot record and all four primary partitions to make a five point loop. Fun!</p>
  <h2>4. The Linux Kernel</h2>
  <p>The kernel does quite a lot really. I think a fair way of summing it up is that it makes the hardware do what the programs want, fairly and efficiently.</p>
  <p>The processor can only execute one instruction at a time, but Linux systems appear to be running lots of things simultaneously. The kernel achieves this by switching from task to task really quickly. It makes the best use of the processor by keeping track of which processes are ready to go, and which ones are waiting for something like a record from a hard disk file, or some keyboard input. This kernel task is called scheduling.</p>
  <p>If a program isn't doing anything, then it doesn't need to be in RAM. Even a program that is doing something, might have parts that aren't doing anything. The address space of each process is divided into pages. The Kernel keeps track of which pages of which processes are being used the most. The pages that aren't used so much can be moved out to the swap partition. When they are needed again, another unused page can be paged out to make way for it. This is virtual memory management.</p>
  <p>If you have ever compiled your own Kernel, you will have noticed that there are many many options for specific devices. The kernel contains a lot of specific code to talk to diverse kinds of hardware, and present it all in a nice uniform way to the application programs.</p>
  <p>The Kernel also manages the filesystem, interprocess communication, and a lot of networking stuff.</p>
  <p>Once the kernel is loaded, the first thing it does is look for an init program to run.</p>
  <h2>4.1 Configuration</h2>
  <p>Most of the configuration of the kernel is done when you build it, using make menuconfig, or make xconfig in /usr/src/linux/ (or wherever your Linux kernel source is). You can reset the default video mode, root filesystem, swap device and RAM disk size using rdev. These parameters and more can also be passed to the kernel from lilo. You can give lilo parameters to pass to the kernel either in lilo.conf, or at the lilo prompt. For example if you wanted to use hda3 as your root file system instead of hda2, you might type<code>LILO: linux root=/dev/hda3</code>.If you are building a system from source, you can make life a lot simpler by creating a ``monolithic'' kernel. That is one with no modules. Then you don't have to copy kernel modules to the target system.</p>
  <p>NOTE: The System.map file is used by the kernel logger to determine the module names generating messages. The program top also uses this information. When you copy the kernel to the target system, copy System.map too.</p>
  <h2>4.2 Exercises</h2>
  <p>Think about this: /dev/hda3 is a special type of file that describes a hard disk partition. But it lives on a file system just like all other files. The kernel wants to know which partition to mount as the root filesystem - it doesn't have a file system yet. So how can it read /dev/hda3 to find out which partition to mount?</p>
  <p>If you haven't already: build your own kernel. Read all the help information for each option.</p>
  <p>See how small a kernel you can make that still works. You can learn a lot by leaving the wrong things out!</p>
  <p>Read ``The Linux Kernel'' (URL below) and as you do, find the parts of the source code that it refers to. The book (as I write) refers to kernel version 2.0.33, which is pretty out of date. It might be easier to follow if you download this old version and read the source there. Its amazing to find bits of C code called ``process'' and ``page''.</p>
  <p>Hack! See if you can make it spit out some extra messages or something.</p>
  <h2>5. The GNU C Library</h2>
  <p>The next thing that happens as your computer starts up is that init is loaded and run. However, init, like almost all programs, uses functions from libraries.<p>
  <p>You may have seen an example C program like this:</p>
  <code>
	  main() {
		  printf("Hello World!\n");
	  }
  </code>
  <p>The program contains no definition of printf, so where does it come from? It comes from the standard C libraries, on a GNU/Linux system, glibc. If you compile it under Visual C++, then it comes from a Microsoft implementation of the same standard functions. There are zillions of these standard functions, for math, string, dates/times memory allocation and so on. Everything in Unix (including Linux) is either written in C or has to try hard to pretend it is, so everything uses these functions.</p>
  <p>If you look in /lib on your linux system you will see lots of files called libsomething.so or libsomething.a etc. They are libraries of these functions. Glibc is just the GNU implementation of these functions.</p>
  <p>There are two ways programs can use these library functions. If you statically link a program, these library functions are copied into the executable that gets created. This is what the libsomething.a libraries are for. If you dynamically link a program (and this is the default), then when the program is running and needs the library code, it is called from the libsomething.so file.</p>
  <p>The command ldd is your friend when you want to work out which libraries are needed by a particular program. For example, here are the libraries that bash uses:</p><code>
	  [greg@Curry power2bash]$ ldd /bin/bash
		  libtermcap.so.2 => /lib/libtermcap.so.2 (0x40019000)
		  libc.so.6 => /lib/libc.so.6 (0x4001d000)
		  /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
  </code></p>
  <h2>5.1 Configuration</h2>
  <p>Some of the functions in the libraries depend on where you are. For example, in Australia we write dates as dd/mm/yy, but Americans write mm/dd/yy. There is a program that comes with the glibc distribution called localedef which enables you to set this up.<p>
  <h2>5.2 Exercises</h2>
  <p>Use ldd to find out what libraries your favourite applications use.</p>
  <p>Use ldd to find out what libraries init uses.</p>
  <p>Make a toy library, with just one or two functions in it. The program ar is used to create them, the man page for ar might be a good place to start investigating how this is done. Write, compile and link a program that uses this library.</p>
  <h2>6. Init</h2>
  <p>I will only talk about the ``System V'' style of init that Linux systems mostly use. There are alternatives. In fact, you can put any program you like in /sbin/init, and the kernel will run it when it has finished loading.</p>
  <p>It is init's job to get everthing running the way it should be. It checks that the file systems are ok and mounts them. It starts up ``daemons'' to log system messages, do networking, serve web pages, listen to your mouse and so on. It also starts the getty processes that put the login prompts on your virtual terminals.</p>
  <p>There is a whole complicated story about switching <i>``run-levels''</i>, but I'm going to mostly skip that, and just talk about system start up.</p>
  <p>Init reads the file /etc/inittab, which tells it what to do. Typically, the first thing it is told to do is to run an initialisation script. The program that executes (or interprets) this script is bash, the same program that gives you a command prompt. In Debian systems, the initialisation script is /etc/init.d/rcS, on Red Hat, /etc/rc.d/rc.sysinit. This is where the filesystems get checked and mounted, the clock set, swap space enabled, hostname gets set etc.</p>
  <p>Next, another script is called to take us into the default run-level. This just means a set of subsystems to start up. There is a set of directories /etc/rc.d/rc0.d, /etc/rc.d/rc1.d, ..., /etc/rc.d/rc6.d in Red Hat, or /etc/rc0.d, /etc/rc1.d, ..., /etc/rc6.d in Debian, which correspond to the run-levels. If we are going into runlevel 3 on a Debian system, then the script runs all the scripts in /etc/rc3.d that start with `S' (for start). These scripts are really just links to scripts in another directory usually called init.d.</p>
  <p>So our run-level script was called by init, and it is looking in a directory for scripts starting with `S'. It might find S10syslog first. The numbers tell the run-level script which order to run them in. So in this case S10syslog gets run first, since there were no scripts starting with S00 ... S09. But S10syslog is really a link to /etc/init.d/syslog which is a script to start and stop the system logger. Because the link starts with an `S', the run-level script knows to execute the syslog script with a ``start'' parameter. There are corresponding links starting with `K' (for kill), which specify what to shut down and in what order when leaving the run-level.</p>
  <p>To change what subsystems start up by default, you must set up these links in the rcN.d directory, where N is the default runlevel set in your inittab.</p>
  <p>The last important thing that init does is to start some getty's. These are ``respawned'' which means that if they stop, init just starts them again. Most distributions come with six virtual terminals. You may want less than this to save memory, or more so you can leave lots of things running and quickly flick to them as you need them. You may also want to run a getty for a text terminal or a dial in modem. In this case you will need to edit the inittab file.</p>
  <h2>6.1 Configuration</h2>
  <p>/etc/inittab is the top level configuration file for init.</p>
  <p>The rcN.d directories, where N = 0, 1, ..., 6 determine what subsystems are started.</p>
  <p>Somewhere in one of the scripts invoked by init, the mount -a command will be issued. This means mount all the file systems that are supposed to be mounted. The file /etc/fstab defines what is supposed to be mounted. If you want to change what gets mounted where when your system starts up, this is the file you will need to edit. There is a man page for fstab.</p>
  <p>Addendum: Decided to read the fstab man page which <strong>is</strong> in the system. But wanted to add it here... Checked Stack Overflow for a way and this command popped out: man fsbab|col -b > destination_file.txt. Really interesting is that it seems by the man page of col itself that the only use for this is exactly to filter the output of a man command from <strong>expected</strong> scape sequences.</p>
  <p>FSTAB(5)</p>
  <p>NAME fstab - static information about the filesystems</p>
  <p>SYNOPSIS /etc/fstab</p>
  <p>DESCRIPTION</p>
  <p>The file fstab contains descriptive information about the filesystems the system can mount. fstab is only read by programs, and not written; it is the duty of the system administrator to properly create and maintain this file. The order of records in fstab is important because fsck(8), mount(8), and umount(8) sequentially iterate through fstab doing their thing.</p>
  <p>Each filesystem is described on a separate line. Fields on each line are separated by tabs or spaces. Lines starting with '#' are comments. Blank lines are ignored.</p>
  <p>The following is a typical example of an fstab entry: <code>LABEL=t-home2   /home      ext4    defaults,auto_da_alloc	  0  2</code> The first field (fs_spec).</p>
  <p>This field describes the block special device, remote filesystem or filesystem image for loop device to be mounted or swap file or swap partition to be enabled.</p>
  <p>For ordinary mounts, it will hold (a link to) a block special device node (as created by mknod(2)) for the device to be mounted, like /dev/cdrom or /dev/sdb7. For NFS mounts, this field is &lt;host&gt;:&lt;dir&gt;, e.g., knuth.aeb.nl:/. For filesystems with no storage, any string can be used, and will show up in df(1) output, for example. Typical usage is proc for procfs; mem, none, or tmpfs for tmpfs. Other special filesystems, like udev and sysfs, are typically not listed in fstab.</p>
  <p>LABEL=&lt;label&gt; or UUID=&lt;uuid&gt; may be given instead of a device name. This is the recommended method, as device names are often a coincidence of hardware detection order, and can change when other disks are added or removed. For example, 'LABEL=Boot' or 'UUID=3e6be9de-8139-11d1-9106-a43f08d823a6'. (Use a filesystem-specific tool like e2label(8), xfs_admin(8), or fatlabel(8) to set LABELs on filesystems).</p>
  <p>It’s also possible to use PARTUUID= and PARTLABEL=. These partitions identifiers are supported for example for GUID Partition Table (GPT).</p>
  <p>See mount(8), blkid(8) or lsblk(8) for more details about device identifiers.</p>
  <p>Note that mount(8) uses UUIDs as strings. The string representation of the UUID should be based on lower case characters. But when specifying the volume ID of FAT or NTFS file systems upper case characters are used (e.g<code> UUID="A40D-85E7" or UUID="61DB7756DB7779B3")</code>.</p>
  <h2>The second field (fs_file).</h2>
  <p>This field describes the mount point (target) for the filesystem. For swap partitions, this field should be specified as `none'. If the name of the mount point contains spaces or tabs these can be escaped as `\040' and '\011' respectively.</p>
  <h2>The third field (fs_vfstype).</h2>
  <p>This field describes the type of the filesystem. Linux supports many filesystem types: ext4, xfs, btrfs, f2fs, vfat, ntfs, hfsplus, tmpfs, sysfs, proc, iso9660, udf, squashfs, nfs, cifs, and many more. For more details, see mount(8).</p>
  <p>An entry swap denotes a file or partition to be used for swapping, cf. swapon(8). An entry none is useful for bind or move mounts.</p>
  <p>More than one type may be specified in a comma-separated list.</p>
  <p>mount(8) and umount(8) support filesystem subtypes. The subtype is defined by '.subtype' suffix. For example 'fuse.sshfs'. It’s recommended to use subtype notation rather than add any prefix to the first fstab field (for example 'sshfs#example.com' is deprecated).</p>
  <h2>The fourth field (fs_mntops).</h2>
  <p>This field describes the mount options associated with the filesystem.</p>
  <p>It is formatted as a comma-separated list of options. It contains at least the type of mount (ro or rw), plus any additional options appropriate to the filesystem type (including performance-tuning options). For details, see mount(8) or swapon(8).</p>
  <h2>Basic filesystem-independent options are:</h2>
  <p><strong>defaults:</strong> use default options: rw, suid, dev, exec, auto, nouser, and async.</p>
  <p><strong>noauto:</strong> do not mount when mount -a is given (e.g., at boot time)</p>
  <p><strong>user:</strong> allow a user to mount</p>
  <p><strong>owner:</strong> allow device owner to mount</p>
  <p><strong>comment:</strong> or x-&lt;name&gt; for use by fstab-maintaining programs</p>
  <p><strong>nofail:</strong> do not report errors for this device if it does not exist.</p>
  <h2>The fifth field (fs_freq).</h2>
  <p>This field is used by dump(8) to determine which filesystems need to be dumped. Defaults to zero (don’t dump) if not present.</p>
  <h2>The sixth field (fs_passno).</h2>
  <p>This field is used by fsck(8) to determine the order in which filesystem checks are done at boot time. The root filesystem should be specified with a fs_passno of 1. Other filesystems should have a fs_passno of 2. Filesystems within a drive will be checked sequentially, but filesystems on different drives will be checked at the same time to utilize parallelism available in the hardware. Defaults to zero (don’t check the filesystem) if not present.</p>
  <h2>FILES</h2>
  <p>/etc/fstab, &lt;fstab.h&gt;</p>
  <h2>NOTES</h2>
  <p>The proper way to read records from fstab is to use the routines getmntent(3) or libmount.</p>
  <p>The keyword ignore as a filesystem type (3rd field) is no longer supported by the pure libmount based mount utility (since util-linux v2.22).</p>
  <h2>HISTORY</h2>
  <p>The ancestor of this fstab file format appeared in 4.0BSD.</p>
  <h2>6.2 Exercises</h2>
  <p>Find the rcN.d directory for the default run-level of your system and do a ls -l to see what the files are links to.</p>
  <p>Change the number of gettys that run on your system.</p>
  <p>Remove any subsystems that you don't need from your default run-level.</p>
  <p>See how little you can get away with starting.</p>
  <p>Set up a floppy disk with lilo, a kernel and a statically linked "hello world" program called /sbin/init and watch it boot up and say hello.</p>
  <p>Watch carefully as your system starts up, and take notes about what it tells you is happening. Or print a section of your system log /var/log/messages from start up time. Then starting at inittab, walk through all the scripts and see what code does what. You can also put extra start up messages in, such as <code> echo "Hello, I am rc.sysinit"</code></p>
  <p>This is a good exercise in learning Bash shell scripting too, some of the scripts are quite complicated. Have a good Bash reference handy.</p><hr>
  <h2>7. The Filesystem</h2>
  <p>In this section, I will be using the word <strong>``filesystem''</strong> in two different ways. There are filesystems on disk partitions and other devices, and there is the filesystem as it is presented to you by a running Linux system. In Linux, you <strong>``mount''</strong> a disk filesystem onto the system's filesystem.</p>
  <p>In the previous section I mentioned that init scripts check and mount the filesystems. The commands that do this are fsck and mount respectively.</p>
  <p>A hard disk is just a big space that you can write ones and zeros on. A filesystem imposes some structure on this, and makes it look like files within directories within directories... Each file is represented by an inode, which says who's file it is, when it was created and where to find its contents. Directories are also represented by inodes, but these say where to find the inodes of the files that are in the directory. If the system wants to read /home/greg/bigfoot.jpeg, it first finds the inode for the root directory / in the ``superblock'', then finds the inode for the directory home in the contents of /, then finds the inode for the directory greg in the contents of /home, then the inode for bigfoot.jpeg which will tell it which disk blocks to read.</p>
  <p>If we add some data to the end of a file, it could happen that the data is written before the inode is updated to say that the new blocks belong to the file, or vice versa. If the power cuts out at this point, the filesystem will be broken. It is this kind of thing that fsck attempts to detect and repair.</p>
  <p>The mount command takes a filesystem on a device, and adds it to the hierarchy that you see when you use your system. Usually, the kernel mounts its root file system read-only. The mount command is used to remount it read-write after fsck has checked that it is ok.</p>
  <p>Linux supports other kinds of filesystem too: msdos, vfat, minix and so on. The details of the specific kind of filesystem are abstracted away by the virtual file system (VFS). I won't go into any detail on this though. There is a discussion of it in <strong>``The Linux Kernel''</strong> (see section The Linux Kernel for a url)</p>
  <p>A completely different kind of filesystem gets mounted on /proc. It is really a representation of things in the kernel. There is a directory there for each process running on the system, with the process number as the directory name. There are also files such as interrupts, and meminfo which tell you about how the hardware is being used. You can learn a lot by exploring /proc.</p>
  <h2>7.1 Configuration</h2>
  <p>There are parameters to the command mke2fs which creates ext2 filesystems. These control the size of blocks, the number of inodes and so on. Check the mke2fs man page for details.</p>
  <p>What gets mounted where on your filesystem is controlled by the /etc/fstab file. It also has a man page.</p>
  <h2>7.2 Exercises</h2>
  <p>Make a very small filesystem, and view it with a hex viewer. Identify inodes, superblocks and file contents.
  <p>I believe there are tools that give you a graphical view of a filesystem. Find one, try it out, and email me the url and a review!</p>
  <h2>8. Kernel Daemons</h2>
  <p>If you issue the ps aux command, you will see something like the following:</p>
  <code>USER       PID %CPU %MEM  SIZE   RSS TTY STAT START   TIME COMMAND</code><br>
  <code>root         1  0.1  8.0  1284   536   ? S    07:37   0:04 init [2]</code><br>
  <code>root         2  0.0  0.0     0     0   ? SW   07:37   0:00 (kflushd)</code><br>
  <code>root         3  0.0  0.0     0     0   ? SW   07:37   0:00 (kupdate)</code><br>
  <code>root         4  0.0  0.0     0     0   ? SW   07:37   0:00 (kpiod)</code><br>
  <code>root         5  0.0  0.0     0     0   ? SW   07:37   0:00 (kswapd)</code><br>
  <code>root        52  0.0 10.7  1552   716   ? S    07:38   0:01 syslogd -m 0</code><br>
  <code>root        54  0.0  7.1  1276   480   ? S    07:38   0:00 klogd</code><br>
  <code>root        56  0.3 17.3  2232  1156   1 S    07:38   0:13 -bash</code><br>
  <code>root        57  0.0  7.1  1272   480   2 S    07:38   0:01 /sbin/agetty 38400 tt</code><br>
  <code>root        64  0.1  7.2  1272   484  S1 S    08:16   0:01 /sbin/agetty -L ttyS1</code><br>
  <code>root        70  0.0 10.6  1472   708   1 R   Sep 11   0:01 ps aux</code><br>
  <p>This is a list of the processes running on the system. The information comes from the <i>/proc filesystem</i> that I mentioned in the previous section. Note that init is process number one. Processes 2, 3, 4 and 5 are kflushd, kupdate, kpiod and kswapd. There is something strange here though: notice that in both the virtual storage size (SIZE) and the Real Storage Size (RSS) columns, these processes have zeroes. How can a process use no memory?</p>
  <p>These processes are the kernel daemons. Most of the kernel does not show up on process lists at all, and you can only work out what memory it is using by subtracting the memory available from the amount on your system. The kernel daemons are started after init, so they get process numbers like normal processes do. But their code and data lives in the kernel's part of the memory.</p>
  <p>There are brackets around the entries in the command column because the <i>/proc filesystem</i> does not contain command line information for these processes.</p>
  <p>So what are these kernel daemons for? Previous versions of this document had a plea for help, as I didn't know much about the kernel daemons. The following partial story has been patched together from various replies to that plea, for which I am most grateful. Further clues, references and corrections are most welcome!</p>
  <p>Input and output is done via buffers in memory. This allows things to run faster. What programs write can be kept in memory, in a buffer, then written to disk in larger more efficient chunks. The daemons kflushd and kupdate handle this work: kupdate runs periodically (5 seconds?) to check whether there are any dirty buffers. If there are, it gets kflushd to flush them to disk.</p>
  <p>Processes often have nothing to do, and ones that are running often don't need all of their code and data in memory. This means we can make better use of our memory, by shifting unused parts of running programs out to the swap partition(s) of the hard disk. Moving this data in and out of memory as needed is done by kpiod and kswapd. Every second or so, kswapd wakes up to check out the memory situation, and if something out on the disk is needed in memory, or there is not enough free memory, kpiod is called in.</p>
  <p>There might also be a kapmd daemon running on your system if you have configured automatic power management into your kernel.</p>
  <h2>8.1 Configuration</h2>
  <p>The program update allows you to configure kflushd and kswapd. Try update -h for some information.</p>
  <p>Swap space is turned on by swapon and off by swapoff. The init script (/etc/rc.sysinit or /etc/rc.d/rc.sysinit) usually calls swapon as the system is coming up. I'm told that swapoff is handy for saving power on laptops.</p>
  <h2>8.2 Exercises</h2>
  <p>Do an update -d, note the blatherings on the last line about ``threshold for buffer fratricide''. Now there's an intriguing concept, go investigate!</p>
  <p>Change directory to <i>/proc/sys/vm</i> and cat the files there. See what you can work out.</p>
  <h2>9. System Logger</h2>
  <p>Init starts the syslogd and klogd daemons. They write messages to logs. The kernel's messages are handled by klogd, while syslogd handles log messages from other processes. The main log is <i>/var/log/messages</i>. This is a good place to look if something is going wrong with your system. Often there will be a valuable clue in there.</p>
  <h2>9.1 Configuration</h2>
  <p>The file <i>/etc/syslog.conf</i> tells the loggers what messages to put where. Messages are identified by which service they come from, and what priority level they are. This configuration file consists of lines that say messages from service x with priority y go to z, where z is a file, tty, printer, remote host or whatever.</p>
  <p>NOTE: Syslog requires the <i>/etc/services</i> file to be present. The services file allocates ports. I am not sure whether syslog needs a port allocated so that it can do remote logging, or whether even local logging is done through a port, or whether it just uses <i>/etc/services</i> to convert the service names you type <i>/etc/syslog.conf</i> into port numbers.</p>
  <h2>9.2 Exercises</h2>
  <p>Have a look at your system log. Find a message you don't understand, and find out what it means.</p>
  <p>Send all your log messages to a tty. (set it back to normal once done)</p>
  <h2>10. Getty and Login</h2>
  <p>Getty is the program that enables you to log in through a serial device such as a virtual terminal, a text terminal, or a modem. It displays the login prompt. Once you enter your username, getty hands this over to login which asks for a password, checks it out and gives you a shell.</p>
  <p>There are many getty's available. Some distributions, including Red Hat use a very small one called mingetty that only works with virtual terminals.</p>
  <p>The login program is part of the util-linux package, which also contains a getty called agetty, which works fine. This package also contains mkswap, fdisk, passwd, kill, setterm, mount, swapon, rdev, renice, more (the program) and more (ie more programs).</p>
  <h2>10.1 Configuration</h2>
  <p>The message that comes on the top of your screen with your login prompt comes from <i>/etc/issue</i>. Gettys are usually started in /etc/inittab. Login checks user details in /etc/passwd, and if you have password shadowing, /etc/shadow.</p>
  <h2>10.2 Exercises</h2>
  <p>Create a <i>/etc/passwd</i> by hand. Passwords can be set to null, and changed with the program passwd once you log on. See the man page for this file Use man 5 passwd to get the man page for the file rather than the man page for the program.</p>
  <h2>11. Bash</h2>
  <p>If you give login a valid username and password combination, it will check in <i>/etc/passwd</i> to see which shell to give you. In most cases on a Linux system this will be bash. It is bash's job to read your commands and see that they are acted on. It is simultaneously a user interface, and a programming language interpreter.</p>
  <p>As a user interface it reads your commands, and executes them itself if they are <i>``internal''</i> commands like cd, or finds and executes a program if they are <i>``external''</i> commands like cp or startx. It also does groovy stuff like keeping a command history, and completing filenames.</p>
  <p>We have already seen bash in action as a programming language interpreter. The scripts that init runs to start the system up are usually shell scripts, and are executed by bash. Having a proper programming language, along with the usual system utilities available at the command line makes a very powerful combination, if you know what you are doing. For example <strong>(smug mode on)</strong> I needed to apply a whole stack of <i>``patches''</i> to a directory of source code the other day. I was able to do this with the following single command:</p>
  <code>for f in /home/greg/sh-utils-1.16*.patch; do patch -p0 &lt; $f; done;</code>
  <p>This looks at all the files in my home directory whose names start with sh-utils-1.16 and end with .patch. It then takes each of these in turn, and sets the variable f to it and executes the commands between do and done. In this case there were 11 patch files, but there could just as easily have been 3000.</p>
  <h2>11.1 Configuration</h2>
  <p>The file <i>/etc/profile</i> controls the system-wide behaviour of bash. What you put in here will affect everybody who uses bash on your system. It will do things like add directories to the PATH, set your MAIL directory variable.</i>
  <p>The default behaviour of the keyboard often leaves a lot to be desired. It is actually readline that handles this. Readline is a separate package that handles command line interfaces, providing the command history and filename completion, as well as some advanced line editing features. It is compiled into bash. By default, readline is configured using the file .inputrc in your home directory. The bash variable INPUTRC can be used to override this for bash. For example in Red Hat 6, INPUTRC is set to <i>/etc/inputrc</i> in <i>/etc/profile</i>. This means that backspace, delete, home and end keys work nicely for everyone.</p>
  <p>Once bash has read the system-wide configuration file, it looks for your personal configuration file. It checks in your home directory for .bash_profile, .bash_login and .profile. It runs the first one of these it finds. If you want to change the way bash behaves for you, without changing the way it works for others, do it here. For example, many applications use environment variables to control how they work. I have the variable EDITOR set to vi so that I can use vi in Midnight Commander (an excellent console based file manager) instead of its editor.</p>
  <h2>11.2 Exercises</h2>
  <p>The basics of bash are easy to learn. But don't stop there: there is an incredible depth to it. Get into the habit of looking for better ways to do things.</p>
  <p>Read shell scripts, look up stuff you don't understand.</p>
  <h2>12. Commands</h2>
  <p>You do most things in bash by issuing commands like cp. Most of these commands are small programs, though some, like cd are built into the shell.</p>
  <p>The commands come in packages, most of them from the Free Software Foundation (or GNU). Rather than list the packages here, I'll direct you to the Linux From Scratch HOWTO. It has a full and up to date list of the packages that go into a Linux system as well as instructions on how to build them.</p>
  <h2>13. Conclusion</h2>
  <p>One of the best things about Linux, in my humble opinion, is that you can get inside it and really find out how it all works. I hope that you enjoy this as much as I do. And I hope that this little note has helped you do it.</p>
</body></html>
